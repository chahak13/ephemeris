<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-05-21 Fri 19:37 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Notes on: Horne, J. S., Garton, E. O., Krone, S. M., &amp; Lewis, J. S. (2007): Analyzing Animal Movements Using  Brownian Bridges</title>
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Notes on: Horne, J. S., Garton, E. O., Krone, S. M., &amp; Lewis, J. S. (2007): Analyzing Animal Movements Using  Brownian Bridges</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4cecdb8">Brownian Bridge Movement Model (BBMM)</a>
<ul>
<li><a href="#org1839294">Probability conditioned on starting and ending points</a></li>
<li><a href="#org49ae5b0">Simulation</a></li>
</ul>
</li>
</ul>
</div>
</div>
<dl class="org-dl">
<dt>tags</dt><dd><a href=notes/20210514170152-monte_carlo_integration_wikipedia.html>Monte Carlo integration - Wikipedia</a></dd>
</dl>

<div id="outline-container-org4cecdb8" class="outline-2">
<h2 id="org4cecdb8">Brownian Bridge Movement Model (BBMM)</h2>
<div class="outline-text-2" id="text-org4cecdb8">
<p>
A creature's movements define a path through an area during a specified period of time from \(t=0\) to \(T_{total}\). Let \(n\) discrete locations along the trajectory be available. Then, the utilization distribution of the space can be modeled using the Brownian Bridge Movement Model (BBMM) when we assume that the movement is conditioned on various starting and ending points.
</p>
</div>

<div id="outline-container-org1839294" class="outline-3">
<h3 id="org1839294">Probability conditioned on starting and ending points</h3>
<div class="outline-text-3" id="text-org1839294">
<p>
Let \(Z_{t}^{a, b, T}\) denote the position of a creature of time \(t \in [0, T]\). It's movement from point \(a\) to point \(b\) can be modelled using a random walk where the movement is conditioned on the points \(a\) and \(b\). Therefore, the values \(Z_{0}^{a, b, T}=a\) and \(Z_{T}^{a, b, T}\) are known values of the random walk in \(\mathbb{R}^2\). This process has a normal distribution \(Z_{t}^{a, b, T} ~ \mathcal{N}(\mu(t), \sigma^2(t)\mathbb{I})\) at time \(t \in [0,T]\), where
</p>

<p>
Here, \(\mathbb{I}\) is the \(2 \times 2\) identity matrix and \(\sigma_{m}^{2}\) is the diffusion coefficient related to the mobility of the creature, i.e. it models the variance in the movement of the creature. The bivariate normal distribution is written as
</p>

<p>
where \(z\) is any location in \(\mathbb{R}^2\). Using these notations, the probability density of a brownian bridge from \(a\) to \(b\) at any point in time is given by
</p>

<p>
To also take into account the instrument errors made in determining positions \(a\) and \(b\), these positions are also modelled as probability density functions. Let these functions be \(f_a(x)\) and \(f_b(y)\) respectively where \(x\) and \(y\) are two-dimensional position vectors in \(\mathbb{R}^2\). Then, the BBMM \(Z_t^T\) can be modelled in terms of finding a creature in an area \(A\) at time \(t \in [0,T]\) as
</p>

<p>
Now, to determine how much time a creature is spending in an area \(A\), we can use indicator function \(1_{A}(x)\)  that take value of 1 if the creature is in the area, 0 otherwise. The random quantity \(\int_0^T 1_{A}(Z_{t}^{T})dt\) then depicts the occupation time for a region \(A\). To find a corresponding probability density function \(h(z)\) we need
</p>

<p>
On solving this, we get
</p>

<p>
Now, when the positional errors are modelled as normal distributions \(\mathcal{N}(a, \delta_a^2\boldsymbol{I}\) and \(\mathcal{N}(b, \delta_b^2\boldsymbol{I}\), this equation can be simplified to
</p>

<p>
where \(\sigma^2(t) = T\alpha(1-\alpha)\sigma_m^2 + (1-\alpha)^2\delta_a^2 + \alpha^2\delta_b^2\) and \(\alpha = t/T\).
</p>
</div>
</div>

<div id="outline-container-org49ae5b0" class="outline-3">
<h3 id="org49ae5b0">Simulation</h3>
<div class="outline-text-3" id="text-org49ae5b0">
<p>
The above model for BBMM between 2 points can be simulated using python. For this, we will use the <code>numpy</code> library and <code>matplotlib</code> for visualization. First, let us import the necessary libraries.
</p>

<div class="org-src-container">
<pre class="src src-python">import numpy as np
import matplotlib.pyplot as plt
</pre>
</div>

<p>
We need to simulate the probability density function \(h(z)\). The required equations for the same are
</p>

<p>
where \(\sigma^2(t) = T\alpha(1-\alpha)\sigma_m^2 + (1-\alpha)^2\delta_a^2 + \alpha^2\delta_b^2\) and \(\alpha = t/T\).
</p>

<p>
and
</p>

<p>
Let us declare these equations as functions to be used during the simulations. First we will write the <code>mu</code> function that calculates \(\mu\) given \(t, a, b, T\). These variables take their standard meaning of observation time, starting point, ending point, and total time respectively.
</p>

<div class="org-src-container">
<pre class="src src-python">def mu(t, a, b, T):
    mu_x = a[:, 0] + (t*(b[:, 0]-a[:, 0]))/T
    mu_y = a[:, 1] + (t*(b[:, 1]-a[:, 1]))/T
    return np.array([mu_x, mu_y])
</pre>
</div>

<p>
We now need to calculate the \(\sigma^2\) values for the bivariate \(\varphi\). Since the we're assuming the probability density for the locations to be circular, \(\sigma^2\) will be scalar values calculated for each time \(t\).
</p>

<div class="org-src-container">
<pre class="src src-python">def sigma2(t, T, sigma_m2, delta_a, delta_b):
    alpha = t/T
    return T*alpha*(1-alpha)*sigma_m2 + ((1-alpha)**2)*(delta_a**2) + (alpha**2)*(delta_b**2)
</pre>
</div>

<p>
Now that we have \(\mu\) and \(\sigma^2\), we can calculate the bivariate \(\varphi\).
n
</p>
<div class="org-src-container">
<pre class="src src-python">def varphi(z, mus, sigma2s):
    breakpoint()
    z_x = (1/np.sqrt(2*np.pi*sigma2s))*np.exp((-(z[0, :]-mus[0, :])/(2*sigma2s)))
    z_y = (1/np.sqrt(2*np.pi*sigma2s))*np.exp((-(z[1, :]-mus[1, :])/(2*sigma2s)))
    return np.array([z_x, z_y])
</pre>
</div>

<p>
Now that we have all the required functions, we can start calculating \(h(z)\) using <a href=20210514170152-monte_carlo_integration_wikipedia.html>monte-carlo integration</a>.
</p>

<div class="org-src-container">
<pre class="src src-python">def monte_carlo_integration(f, lower_lim, upper_lim, n_estimators, N, *args):
    rng = np.random.default_rng()

    r = rng.uniform(lower_lim, upper_lim, size=(n_estimators, N))
    result = (1/n_estimators)*((upper_lim-lower_lim)/N)*(np.sum(f(r, *args)))
    return result
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def h(z, a, b, T, n_estimators, N, sigma_m2, delta_a, delta_b):
    rng = np.random.default_rng()

    t = rng.uniform(0, T, size=(n_estimators, N))
    mus = mu(t, a, b, T)
    sigma2s = sigma2(t, T, sigma_m2, delta_a, delta_b)
    varphis = varphi(z, mus, sigma2s)
    hz = (1/T)*(1/n_estimators)*((T-0)/N)*np.sum(varphis)
    return hz
</pre>
</div>

<p>
Let us simulate one such BBMM using the following values:
</p>
<ul class="org-ul">
<li>\(\sigma_m^2 = 642\)</li>
<li>\(\delta_a = \delta_b = 28.85\) m</li>
<li>\(a = (0, 0)\) and \(b = (0, 280\)</li>
<li>\(T = 20\) min</li>
</ul>

<div class="org-src-container">
<pre class="src src-python">T = 20
a, b = np.array([[0, 0]]), np.array([[0, 280]])
delta_a = delta_b = 28.85
sigma_m2 = 642
n_estimators = 1
N = 100
x = np.arange(-1, 285, 0.5)
y = np.zeros(x.shape)
z = np.meshgrid(x, y)[0]

prob_density = h(z, a, b, T, n_estimators, N, sigma_m2, delta_a, delta_b)
</pre>
</div>


<p>
We can then visualize this probability density using matplotlib
</p>

<div class="org-src-container">
<pre class="src src-python">fig, ax = plt.subplots()
ax.plot(np.linspace(0, 280, len(prob_density)), prob_density)
plt.show()
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2021-05-21 Fri 19:37</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
